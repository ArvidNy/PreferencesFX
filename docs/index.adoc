= PreferencesFX
François Martin; Marco Sanfratello

//Table of contents
:toc:

== Abstract / Management summary

----- ToDo -----

== Introduction
The PreferenesFX API creates a preferences window. This is done by simply writing a title and giving it a property and all the other work is done by the API itself. Often developers have no time, energy or simply not mind to write a preferences window for their application. It’s a generic, boring work which nobody really wants to do. The picture below shows the final result of the PreferencesFX API in use.

image::images/preferencesFX_in_use.png[PreferencesFX in use]

The idea of the PreferencesFX API is to replace this boring work with a much simpler, cleaner solution. Always in mind to relieve this part of a developers work as much as possible, this solution was created.

The PreferencesFX API works with a fluent API approach (for further information ). The developer can build up his preferences window by simply calling function after function to define it further. Each preference which needs to be stored represents a setting. One or multiple settings are collected in a group. One or multiple groups are collected in a category and the preferences window consists of one or multiple categories.

The project itself is programmed with a model view presenter structure, which separates the frontend and backend to ensure a clear overview.

In the following chapters, the reader will gain additional insights of the projects structure and the features the PreferencesFX API provides.

== Definitions
The following chapter explains several important definitions which are mentionned in this document.

=== Fluent API
The user of the `PreferencesFX API` builds his preferences dialog using the so called fluent API. This means, that the structure of creating was implemented the way, that one could (theoretically) write the whole dialog in one line. This is done by using methods, which are returning the same object on which the method is called.

A famous example of the fluent API in use are streams. Our customer wanted us to apply it the same way in the `PreferencesFX API`. The code snippet below, which is used in `RootPane.java`, shows how the preferences are set up and the fluent API is used:

:sourcedir: ../src/main/java
:sourcedirdemo: ../preferencesfx-demo/src/main/java

[source,java]
----
include::{sourcedirdemo}/com/dlsc/preferencesfx/standard/RootPane.java[tags=setupPreferences]
----

The whole code snippet uses the fluent API, but to explain it the best let's have a look at the last line of code. There are several methods called.

One can see in the code snippet below, that the method returns exactly the object on which this method was called. This style of implementation allows the user of the API a simple, intuitive and easy way to create the preferences. This method is being used in `PreferencesFx.java`:

[source,java]
----
include::{sourcedir}/com/dlsc/preferencesfx/PreferencesFx.java[tags=fluentApiMethod]
----

== The way to PreferencesFX
=== Briefing
Our customer is Dirk Lemmermann, CEO of Dirk Lemmermann - Software and Consulting (http://dlsc.com/[dlsc.com]). One of his former projects was the FormsFX API, where a developer can easily create forms without a lot of effort. FormsFX uses the fluent API approach to create its forms. His approach was to adapt this idea of an easy way to create a structure with a predefined User Interface to preference windows. The developer should not need to invest a lot of time creating a preferences window. We got access to a fork of FormsFX. Our customer allowed us to use it for creation of our project.

Regarding the visual appearance we should orientate ourselves at the preferences window of the programming platform Intellij IDEA regarding the look and feel.


=== First thoughts
Well, we didn't just started programming. In fact we did some research. Although our customer had initial some ideas, we did not just accept and implement these. In the following chapters we're going to discuss our initial steps and thoughts on how to set up our project.

==== Persona
This applied together with the search after the perfect layout. We asked ourselfs: What would be the target group? Well of course everyone which would ever use an application which uses the `PreferencesFX API`. But this was not really a strict persona. Because this could be literally anyone.

Another thought was, that we did not really have influence of the final application, the developer decides to create. If he decides for example to create three different preferences windows it's not really our fault that the application has a bad usability. Of course we need to do our best to give a developer no reasons to do such things, but in general we don't really can change something.

Or what about different types of applications? For example an application for financiers would look different than one for carpenters.

In conclusion we discovered, that our primary persona was not the end user of an application, but we realized, that the developer of the application was our persona. Why? Well of course we would consider the layout of the preference dialog as important, but the developer of the application should be able to create a preferences window as fast and as simple as possible.

==== Layout
As stated before, the layout of the preferences dialog was considered as important. For that reason we looked at various preferences windows and noted the usual best practices and the do's and dont's which are made through the last years.

===== Eclipse RCP

[cols="1,1"]
.Eclipse RCP
|===
|image:images/alternatives/eclipse_rcp.png[rcp1] Eclipse RCP, window 1| image:images/alternatives/eclipse_rcp1.png[rcp2] Eclipse RCP, window 2
|===

===== IOS

[cols="1,1"]
.IOS
|===
|image:images/alternatives/ios_internal.jpg[internal] Internal IOS application |image:images/alternatives/ios_external.jpg[external] External IOS application
|===

===== Intellij
Intellij is one of the good examples, which does pretty much right. In contrary we discovered at other platforms a lot of visual displeasing layouts. For example were a lot of settings framed by a lot of borders, which is totally unnecessary if one would use the "gestalt principles".

[cols="1,1"]
.Intellij
|===
|image:images/alternatives/intellij.png[intellij] Standard Intellij dialog | image:images/alternatives/intellij_undoRedo.png[undo/redo] Undo/Redo buttons
|===

===== Minimal viable product
As a result of our research we created a paper prototype, which was also the minimal viable product (MVP). Our promise to our customer, that he gets at least this product from us. The MVP is shown in the picture below:

image::images/minimal_viable_product.png[Minimal viable product]

==== The way creating the preferences
We also did some research about how would a developer use the PreferencesFX API. When someone usually uses any JavaFX components, for example a `MenuBar`, he writes in the following code style:

[source,java]
----
MenuBar menuBar = new MenuBar();
Menu menu = new Menu("Menu");
MenuItem menuItem = new MenuItem("Menu Item");

menu.getItems().add(menuItem);
menuBar.getMenus().add(menu);
----

According to this code style we wrote first pseudo code snippets to try using the PreferencesFX API in this style:

[source,java]
----
PreferencesFx preferencesFx = new PreferencesFx();
Category category = new Category("Category");
Group group = new Group("Group");
Setting setting = new Setting("Setting", new SimpleBooleanProperty(true));

group.getSettings().add(setting);
category.getGroups().add(group);
preferencesFx.getCategories().add(category);
----

The second try was with the fluent API approach, like our customer suggested:

[source,java]
----
PreferencesFx preferencesFx = PreferencesFx.of(
    Category.of("Category",
        Group.of("Group",
            Setting.of("Setting", new SimpleBooleanProperty(true))
        )
    )
);
----

The reason why we finally were convinced that the fluent API approach was the right way, was how intuitive it was to write the code and how clearly arranged the code was. That way everyone sees what is a setting and what is a category. Especially when an application has literally hundreds of preferences which are needed to store.

==== Using FormsFX or not
Another question we asked ourselves, was if we should use the former project FormsFX or not. We had serious concerns if the projects had bugs we had to deal with in the future. Another concern was, that we needed to get to know the project. The question was, if the time we'd need to invest to overcome all of this concerns would match the time we'd save when using the project. For example we could use the base structure and all of the widgets which were already programmed in the project.

At last we decided to take the risk and use the FormsFX project, fully aware that it might has some bugs we have to deal with.

==== Started programming
We don't wanted to spend any more time researching. So we just started programming and tried to write as fast as possible some code down to have something to work on. This helped a lot to early have some satisfying experiences in the project and keep us motivated.

=== Challenges
During our project we faced several challenges, which we needed to overcome. In the following chapters we'll have a look at the most important ones.

==== Instant persistence
We discovered that preferences windows often provide the user a lot of buttons, like close, discard, apply and more. All of this buttons have their reasons. But in general the huge amount of buttons disturbed us. For that reason we decided to build the API the way, that changes in the preferences are applied instant. This way we got rid of the buttons.

In case a developer still wants to have buttons, the API provides the method `setButtonsVisible()` which allows him to define the visibility of the buttons. There are two button types available: `Close` and `Decline`. The close button just closes the window and leaves the preferences as they are. THe decline button discards all changes which are made during the time the dialog was last opened.

The instant persistence brought up a new problem: What shall the application do, when a user wants to revert his last change? For this case we came up with an implementation of `undo/redo buttons`. This way a user can return all of his changes back to his first one.

==== FormsFX Bugs

===== GridPane
----- ToDo -----

===== Bidirectional binding
Another bug occured when we were implementing the support of the setting type `ListViewControl`. For some reason the alredy

===== Design for inheritance
Problem with package private and private

==== Möglichst korrekt
einerseits gut, vorwärts, andererseits problem mit refactoring

==== Code refactoring
Architektur

==== StorageHandler
Problems, herausforderungen

==== Undo/Redo
not in javafx
--> UndoFX gibt es, aber kompliziert implementiert

==== Search
Own implementation
A lot of work
FilterableTreeItems
link zum anderen Dokument
Schwierig eine intuitive suche zu programmieren regarding cat, group, sett

----- ToDo -----

=== Architecture
We decided to implement our project in the model view presenter architecture. This means, that the model and the views are separarted from each other. This means that this parts have a small cohesion. This has the major advantage that the views can easily be exchanged. For example if someone wants in the future a new layout, he can do this relatively easy. To make sure that the possibly new view parts are fitting in the project structure, they need to fulfill certain characteristics. This is guaranteed by implementing interfaces. For this reason we created the two interfaces `View` and `Presenter`. The picture below illustrates a simplified version of our project structure.

image::images/UML_diagram.png[UML diagram]

Here is clearly shown, that the user only creates one instance of the `PreferencesFx` and saves it in his application. This is done in the package `Demo`.

In the Package `PreferencesFx` there is the class `PreferencesFx` which is called, when the preferences are created. In the constructor of the class is the `PreferencesModel` created. Afterwards, all views and their constructors are created, which are needed to visualize the preferences dialog. Simply said is the PreferencesFx class used as a controller to manage the frontend and the backend.

The views and the presenters are built the way, that the views only contain visual elements and the presenters regulate the logical parts, like listeners or complex functions, ect. This has the immense advantage of having a clear overview.

After creating the preferences one can simply call the method `show()` and the `PreferencesFx` opens a `PreferencesDialog`. This dialog contains the `PreferencesView` which puts all other views together.

== Lessons learned
* We just started programming and didn't mind about separating the frontend from the backend. This had the disadvantage, that we needed to invest a lot of time to separate it at the end of the project. For the next project we are going to focus more on the system architecture in first place.

* We found a bug in FormsFX and fixed it. But the time it took was too much. Of course our customer is happy, that the bug is solved, but in an industrial project we mustn't do this. This is not our problem. It's the one of the FormsFX team. Next time we will discuss the situation with our customer and ask him about his opinion.